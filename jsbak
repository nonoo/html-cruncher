package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"sync"

	"github.com/robertkrimen/otto/parser"
)

// JSLoad loads all tags from the given file.
func JSLoad(wg *sync.WaitGroup, fileName string) {
	defer wg.Done()

	fmt.Println("js: loading tags from " + fileName)

	fileData, err := ioutil.ReadFile(fileName)
	if err != nil {
		fmt.Println("js error: can't open " + fileName + ": " + err.Error())
		return
	}

	p := parser.NewParser("", string(fileData))

	var lastIdentifier string
	for {
		token, literal, idx := p.Scan()

		// fmt.Printf("%s|%s\n", token.String(), literal)

		switch token.String() {
		case "EOF":
			fmt.Println("js: loading tags from " + fileName + " finished")
			return
		case "IDENTIFIER":
			lastIdentifier = literal
		case "STRING":
			trimmedLiteral := strings.Trim(literal, "'\"")

			switch lastIdentifier {
			case "getElementById":
				TagAdd(TagTypeID, fileName, trimmedLiteral, true)
			case "getElementsByClassName":
				TagAdd(TagTypeClass, fileName, trimmedLiteral, true)
			case "hasClass":
				TagAdd(TagTypeClass, fileName, trimmedLiteral, true)
			case "addClass":
				TagAdd(TagTypeClass, fileName, trimmedLiteral, true)
			case "removeClass":
				TagAdd(TagTypeClass, fileName, trimmedLiteral, true)
			case "querySelector":
				CSSProcess(fileName, trimmedLiteral, idx)
			case "$":
				CSSProcess(fileName, trimmedLiteral, idx)
			}
		}
	}
}

// JSReplaceTags replaces all known tags to their new names.
func JSReplaceTags(wg *sync.WaitGroup, fileName string, outDirName string) {
	defer wg.Done()

	fmt.Println("js: replacing tags in " + fileName)

	fileData, err := ioutil.ReadFile(fileName)
	if err != nil {
		fmt.Println("js error: can't open " + fileName + ": " + err.Error())
		return
	}

	err = os.MkdirAll(filepath.Dir(outDirName+"/"+fileName), 0777)
	if err != nil {
		fmt.Println("js error: can't create output directory " + outDirName +
			": " + err.Error())
		return
	}

	fo, err := os.Create(outDirName + "/" + fileName)
	if err != nil {
		fmt.Println("js error: can't write " + outDirName + "/" +
			fileName + ": " + err.Error())
		return
	}
	defer fo.Close()

	p := parser.NewParser("", string(fileData))

	var lastIdentifier string
	var lastToken string
	for {
		token, literal, idx := p.Scan()

		if token.String() == "EOF" {
			var bytesIn int64
			var bytesOut int64

			fi, e := os.Stat(fileName)
			if e == nil {
				bytesIn = fi.Size()
			}

			fi, e = fo.Stat()
			if e == nil {
				bytesOut = fi.Size()
			}

			fmt.Printf("js: replacing tags in "+fileName+" finished (%d -> %d, %.1f%%)\n",
				bytesIn, bytesOut, (float64(bytesOut)/float64(bytesIn))*100)
			return
		}

		// if filepath.Base(fileName) == "d3.min.js" {
		// 	fmt.Printf("%s|%s\n", token.String(), literal)
		// }

		switch token.String() {
		case "IDENTIFIER":
			lastIdentifier = literal
			fo.WriteString(literal)
		case "STRING":
			trimmedLiteral := strings.Trim(literal, "'\"")

			switch lastIdentifier {
			case "getElementById":
				tag, err := TagGet(TagTypeID, trimmedLiteral)
				if err == nil {
					literal = strings.Replace(literal, trimmedLiteral, tag.NewName, 1)
					fo.WriteString(literal)
				}
			case "getElementsByClassName":
				tag, err := TagGet(TagTypeClass, trimmedLiteral)
				if err == nil {
					literal = strings.Replace(literal, trimmedLiteral, tag.NewName, 1)
					fo.WriteString(literal)
				}
			case "hasClass":
				tag, err := TagGet(TagTypeClass, trimmedLiteral)
				if err == nil {
					literal = strings.Replace(literal, trimmedLiteral, tag.NewName, 1)
					fo.WriteString(literal)
				}
			case "addClass":
				tag, err := TagGet(TagTypeClass, trimmedLiteral)
				if err == nil {
					literal = strings.Replace(literal, trimmedLiteral, tag.NewName, 1)
					fo.WriteString(literal)
				}
			case "removeClass":
				tag, err := TagGet(TagTypeClass, trimmedLiteral)
				if err == nil {
					literal = strings.Replace(literal, trimmedLiteral, tag.NewName, 1)
					fo.WriteString(literal)
				}
			case "querySelector":
				var buf bytes.Buffer
				err := CSSReplaceFromString(trimmedLiteral, &buf, fileName, idx)
				if err == nil {
					fo.WriteString(string([]rune(literal)[0]))
					buf.WriteTo(fo)
					fo.WriteString(string([]rune(literal)[0]))
				} else {
					fmt.Print(err.Error())
					fo.WriteString(literal)
				}
			case "$":
				var buf bytes.Buffer
				err := CSSReplaceFromString(trimmedLiteral, &buf, fileName, idx)
				if err == nil {
					fo.WriteString(string([]rune(literal)[0]))
					buf.WriteTo(fo)
					fo.WriteString(string([]rune(literal)[0]))
				} else {
					fmt.Print(err.Error())
					fo.WriteString(literal)
				}
			default:
				fo.WriteString(literal)
			}

			lastIdentifier = ""
		case "NUMBER":
			fo.WriteString(literal)
		case "NULL":
			fo.WriteString(literal)
		case "BOOLEAN":
			fo.WriteString(literal)
		case "KEYWORD":
			fo.WriteString(literal)
		case "COMMENT":
			fo.WriteString(literal)
		case "ILLEGAL":
			fo.WriteString(literal)
		case "in":
			fo.WriteString(" " + token.String() + " ")
		case "var":
			fo.WriteString(token.String() + " ")
		case "new":
			fo.WriteString(token.String() + " ")
		case "case":
			fo.WriteString(token.String() + " ")
		case "with":
			fo.WriteString(token.String() + " ")
		case "while":
			fo.WriteString(token.String() + " ")
		case "catch":
			fo.WriteString(token.String() + " ")
		case "throw":
			fo.WriteString(token.String() + " ")
		case "return":
			fo.WriteString(token.String() + " ")
		case "typeof":
			fo.WriteString(token.String() + " ")
		case "delete":
			fo.WriteString(token.String() + " ")
		case "finally":
			fo.WriteString(token.String() + " ")
		case "function":
			fo.WriteString(token.String() + " ")
		case "debugger":
			fo.WriteString(token.String() + " ")
		case "instanceof":
			fo.WriteString(" " + token.String() + " ")
		case "else":
			fo.WriteString("\n" + token.String() + " ")
		case "++":
			if lastToken == "+" {
				fo.WriteString(" " + token.String())
			}
		case "{":
			fo.WriteString("{\n")
		case "}":
			fo.WriteString("}\n")
		case ";":
			fo.WriteString(";\n")
		default:
			fo.WriteString(token.String())
		}
		lastToken = token.String()
	}
}
